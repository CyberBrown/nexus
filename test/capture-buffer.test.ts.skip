import { describe, it, expect, beforeAll } from 'vitest';
import { env, createExecutionContext, waitOnExecutionContext } from 'cloudflare:test';
import type { Env } from '../src/types/index.ts';

describe('CaptureBuffer Durable Object', () => {
  let tenantId: string;
  let userId: string;

  beforeAll(() => {
    tenantId = crypto.randomUUID();
    userId = crypto.randomUUID();
  });

  it('should initialize with default config', async () => {
    const id = env.CAPTURE_BUFFER.idFromName(`${tenantId}:${userId}`);
    const stub = env.CAPTURE_BUFFER.get(id);

    const response = await stub.fetch('http://do/status');
    const data = await response.json();

    expect(data.success).toBe(true);
    expect(data.data.config).toEqual({
      maxChunks: 50,
      maxAgeMs: 5000,
      mergeWindowMs: 2000,
    });
  });

  it('should append a chunk to buffer', async () => {
    const id = env.CAPTURE_BUFFER.idFromName(`${tenantId}:${userId}`);
    const stub = env.CAPTURE_BUFFER.get(id);

    const response = await stub.fetch('http://do/append', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tenant_id: tenantId,
        user_id: userId,
        content: 'Test chunk 1',
        source_type: 'text',
      }),
    });

    const data = await response.json();
    expect(data.success).toBe(true);
    expect(data.data.buffer_length).toBeGreaterThan(0);
    expect(data.data.total_chunks).toBeGreaterThan(0);
  });

  it('should merge chunks within merge window', async () => {
    const id = env.CAPTURE_BUFFER.idFromName(`${tenantId}:${userId}2`);
    const stub = env.CAPTURE_BUFFER.get(id);

    // Append first chunk
    await stub.fetch('http://do/append', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tenant_id: tenantId,
        user_id: userId,
        content: 'First chunk',
        source_type: 'voice',
      }),
    });

    // Append second chunk immediately (within merge window)
    await stub.fetch('http://do/append', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tenant_id: tenantId,
        user_id: userId,
        content: 'Second chunk',
        source_type: 'voice',
      }),
    });

    // Check buffer
    const bufferResponse = await stub.fetch('http://do/buffer');
    const bufferData = await bufferResponse.json();

    expect(bufferData.success).toBe(true);
    // Should have 1 capture with 2 chunks (merged)
    expect(bufferData.data.buffer.length).toBe(1);
    expect(bufferData.data.buffer[0].chunk_count).toBe(2);
  });

  it('should get buffer status', async () => {
    const id = env.CAPTURE_BUFFER.idFromName(`${tenantId}:${userId}3`);
    const stub = env.CAPTURE_BUFFER.get(id);

    // Add a chunk
    await stub.fetch('http://do/append', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tenant_id: tenantId,
        user_id: userId,
        content: 'Status test',
        source_type: 'text',
      }),
    });

    const response = await stub.fetch('http://do/status');
    const data = await response.json();

    expect(data.success).toBe(true);
    expect(data.data.buffer_length).toBe(1);
    expect(data.data.total_chunks).toBe(1);
    expect(data.data.tenantId).toBe(tenantId);
  });

  it('should configure buffer settings', async () => {
    const id = env.CAPTURE_BUFFER.idFromName(`${tenantId}:${userId}4`);
    const stub = env.CAPTURE_BUFFER.get(id);

    const configResponse = await stub.fetch('http://do/configure', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        maxChunks: 100,
        maxAgeMs: 10000,
      }),
    });

    const configData = await configResponse.json();
    expect(configData.success).toBe(true);

    // Verify config was updated
    const statusResponse = await stub.fetch('http://do/status');
    const statusData = await statusResponse.json();

    expect(statusData.data.config.maxChunks).toBe(100);
    expect(statusData.data.config.maxAgeMs).toBe(10000);
    expect(statusData.data.config.mergeWindowMs).toBe(2000); // unchanged
  });

  it('should handle is_final flag for voice', async () => {
    const id = env.CAPTURE_BUFFER.idFromName(`${tenantId}:${userId}5`);
    const stub = env.CAPTURE_BUFFER.get(id);

    // Mock InboxManager to prevent flush errors
    const inboxId = env.INBOX_MANAGER.idFromName(tenantId);
    const inboxStub = env.INBOX_MANAGER.get(inboxId);

    // Initialize InboxManager
    await inboxStub.fetch('http://do/capture', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tenant_id: tenantId,
        user_id: userId,
        input: {
          source_type: 'voice',
          raw_content: 'initialization',
          captured_at: new Date().toISOString(),
        },
      }),
    });

    // Append chunk with is_final=false
    await stub.fetch('http://do/append', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tenant_id: tenantId,
        user_id: userId,
        content: 'Voice chunk',
        source_type: 'voice',
        is_final: false,
      }),
    });

    // Buffer should have 1 item
    let bufferResponse = await stub.fetch('http://do/buffer');
    let bufferData = await bufferResponse.json();
    expect(bufferData.data.buffer.length).toBe(1);

    // Append chunk with is_final=true
    await stub.fetch('http://do/append', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tenant_id: tenantId,
        user_id: userId,
        content: 'Final chunk',
        source_type: 'voice',
        is_final: true,
      }),
    });

    // Should auto-flush, so buffer might be empty or flushing
    // Give it a moment to flush
    await new Promise(resolve => setTimeout(resolve, 100));

    const statusResponse = await stub.fetch('http://do/status');
    const statusData = await statusResponse.json();

    // Buffer should be empty or smaller after auto-flush
    expect(statusData.data.buffer_length).toBeLessThanOrEqual(1);
  });

  it('should return buffer contents', async () => {
    const id = env.CAPTURE_BUFFER.idFromName(`${tenantId}:${userId}6`);
    const stub = env.CAPTURE_BUFFER.get(id);

    // Add some chunks
    await stub.fetch('http://do/append', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tenant_id: tenantId,
        user_id: userId,
        content: 'Buffer test 1',
        source_type: 'text',
      }),
    });

    await stub.fetch('http://do/append', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tenant_id: tenantId,
        user_id: userId,
        content: 'Buffer test 2',
        source_type: 'text',
      }),
    });

    const response = await stub.fetch('http://do/buffer');
    const data = await response.json();

    expect(data.success).toBe(true);
    expect(data.data.buffer).toBeInstanceOf(Array);
    expect(data.data.buffer.length).toBeGreaterThan(0);

    const capture = data.data.buffer[0];
    expect(capture).toHaveProperty('id');
    expect(capture).toHaveProperty('user_id');
    expect(capture).toHaveProperty('source_type');
    expect(capture).toHaveProperty('chunk_count');
    expect(capture).toHaveProperty('status');
  });
});
