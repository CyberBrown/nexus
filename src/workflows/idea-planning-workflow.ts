import { WorkflowEntrypoint, WorkflowStep, type WorkflowEvent } from 'cloudflare:workers';
import type { Env } from '../types/index.ts';
import { getEncryptionKey, decryptField, encryptField } from '../lib/encryption.ts';

/**
 * IdeaPlanningWorkflow
 *
 * Handles the complete idea → plan → tasks pipeline with human-in-the-loop approval.
 *
 * Steps:
 * 1. generate-plan: Call DE text-gen worker to create execution plan
 * 2. wait-for-approval: Pause for human review (can wait for days)
 * 3. create-tasks: Generate tasks from approved plan, insert into D1
 * 4. track-completion: Monitor task status, surface blockers
 */

// Parameters passed to the workflow
interface IdeaPlanningParams {
  idea_id: string;
  tenant_id: string;
  user_id: string;
  execution_id: string;
}

// Execution plan generated by AI
interface ExecutionPlan {
  summary: string;
  approach: string;
  steps: PlanStep[];
  estimatedEffort: 'xs' | 's' | 'm' | 'l' | 'xl';
  risks: string[];
  dependencies: string[];
}

interface PlanStep {
  order: number;
  title: string;
  description: string;
  type: 'research' | 'design' | 'implement' | 'test' | 'deploy' | 'document';
  agent_type: 'claude' | 'local' | 'human';
  estimatedMinutes: number;
}

// Idea data from database
interface IdeaData {
  id: string;
  title: string;
  description: string | null;
  category: string;
  domain: string | null;
}

// Approval event payload
interface ApprovalEvent {
  approved: boolean;
  modifications?: {
    remove_steps?: number[]; // step orders to remove
    notes?: string;
  };
}

// Task generated from plan
interface GeneratedTask {
  taskId: string;
  title: string;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
}

export class IdeaPlanningWorkflow extends WorkflowEntrypoint<Env, IdeaPlanningParams> {
  override async run(event: WorkflowEvent<IdeaPlanningParams>, step: WorkflowStep) {
    const { idea_id, tenant_id, user_id, execution_id } = event.payload;

    // Step 1: Load idea from D1
    const idea = await step.do('load-idea', async () => {
      const row = await this.env.DB.prepare(`
        SELECT id, title, description, category, domain
        FROM ideas
        WHERE id = ? AND tenant_id = ? AND deleted_at IS NULL
      `).bind(idea_id, tenant_id).first<IdeaData>();

      if (!row) {
        throw new Error(`Idea not found: ${idea_id}`);
      }

      // Decrypt fields
      const key = await getEncryptionKey(this.env.KV, tenant_id);
      const title = await decryptField(row.title, key);
      const description = row.description ? await decryptField(row.description, key) : null;

      return { ...row, title, description };
    });

    // Step 2: Update execution status to 'planning'
    await step.do('update-status-planning', async () => {
      const now = new Date().toISOString();
      await this.env.DB.prepare(`
        UPDATE idea_executions
        SET status = 'planning', started_at = ?, updated_at = ?
        WHERE id = ?
      `).bind(now, now, execution_id).run();

      await this.env.DB.prepare(`
        UPDATE ideas
        SET execution_status = 'planned', updated_at = ?
        WHERE id = ?
      `).bind(now, idea_id).run();
    });

    // Step 3: Generate plan via DE text-gen worker
    const plan = await step.do(
      'generate-plan',
      {
        retries: {
          limit: 3,
          delay: '5 seconds',
          backoff: 'exponential',
        },
        timeout: '3 minutes',
      },
      async () => {
        return await this.generatePlanWithDE(idea);
      }
    );

    // Step 4: Store plan in database and wait for approval
    await step.do('store-plan', async () => {
      const now = new Date().toISOString();
      await this.env.DB.prepare(`
        UPDATE idea_executions
        SET status = 'planned', plan = ?, planned_at = ?, updated_at = ?
        WHERE id = ?
      `).bind(JSON.stringify(plan), now, now, execution_id).run();
    });

    // Step 5: Wait for human approval (can wait indefinitely)
    const approvalEvent = await step.waitForEvent<ApprovalEvent>('plan-approved', {
      type: 'plan-approved',
      timeout: '30 days', // Can wait up to 30 days for approval
    });

    // Step 6: Handle approval decision
    const approval = approvalEvent.payload;
    if (!approval.approved) {
      await step.do('mark-rejected', async () => {
        const now = new Date().toISOString();
        await this.env.DB.prepare(`
          UPDATE idea_executions
          SET status = 'cancelled', error_message = 'Plan rejected by user', updated_at = ?
          WHERE id = ?
        `).bind(now, execution_id).run();

        await this.env.DB.prepare(`
          UPDATE ideas
          SET execution_status = 'new', updated_at = ?
          WHERE id = ?
        `).bind(now, idea_id).run();
      });

      return {
        success: false,
        idea_id,
        execution_id,
        reason: 'Plan rejected by user',
      };
    }

    // Step 7: Apply any modifications to the plan
    let finalPlan = plan;
    const modifications = approval.modifications;
    if (modifications?.remove_steps?.length) {
      finalPlan = {
        ...plan,
        steps: plan.steps.filter(s => !modifications.remove_steps!.includes(s.order)),
      };
    }

    // Step 8: Create tasks from approved plan
    const tasks = await step.do('create-tasks', async () => {
      return await this.createTasksFromPlan(finalPlan, idea_id, tenant_id, user_id, execution_id);
    });

    // Step 9: Update execution status to 'executing'
    await step.do('update-status-executing', async () => {
      const now = new Date().toISOString();
      await this.env.DB.prepare(`
        UPDATE idea_executions
        SET status = 'executing', total_tasks = ?, updated_at = ?
        WHERE id = ?
      `).bind(tasks.length, now, execution_id).run();

      await this.env.DB.prepare(`
        UPDATE ideas
        SET execution_status = 'executing', updated_at = ?
        WHERE id = ?
      `).bind(now, idea_id).run();
    });

    return {
      success: true,
      idea_id,
      execution_id,
      tasks_created: tasks.length,
      tasks: tasks.map(t => ({ id: t.taskId, title: t.title })),
    };
  }

  /**
   * Generate execution plan using DE text-gen worker via HTTP
   * Routes through DE's LLM router for automatic provider fallback
   * Note: Cloudflare Workflows can't use service bindings, must use HTTP fetch
   */
  private async generatePlanWithDE(idea: IdeaData): Promise<ExecutionPlan> {
    const textGenUrl = this.env.TEXT_GEN_URL;
    if (!textGenUrl) {
      throw new Error('TEXT_GEN_URL not configured. Set TEXT_GEN_URL in wrangler.toml [vars]');
    }

    const systemPrompt = this.getPlanningSystemPrompt();
    const userPrompt = this.buildPlanningPrompt(idea);

    // DE's text-gen service expects a prompt-based request
    const prompt = `System: ${systemPrompt}\n\nUser: ${userPrompt}\n\nAssistant:`;

    // Route through DE text-gen - let the router use its provider chain
    const response = await fetch(`${textGenUrl}/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt,
        max_tokens: 2048,
        temperature: 0.7,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`DE text-gen error: ${response.status} - ${error}`);
    }

    const data = await response.json() as {
      success: boolean;
      text: string;
      metadata?: {
        provider: string;
        model: string;
        tokens_used: number;
      };
    };

    if (!data.success || !data.text) {
      throw new Error('DE returned empty response');
    }

    console.log(`Plan generated via DE text-gen (${data.metadata?.provider || 'unknown'})`);
    return this.parsePlanResponseFromText(data.text);
  }

  /**
   * Parse plan from raw text response (used by DE service binding)
   */
  private parsePlanResponseFromText(text: string): ExecutionPlan {
    if (!text) {
      throw new Error('No response from AI');
    }

    // Strip markdown code blocks
    text = text.trim();
    if (text.startsWith('```json')) {
      text = text.slice(7);
    } else if (text.startsWith('```')) {
      text = text.slice(3);
    }
    if (text.endsWith('```')) {
      text = text.slice(0, -3);
    }
    text = text.trim();

    // Extract JSON if wrapped in other content
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('Failed to parse plan from AI response');
    }

    return JSON.parse(jsonMatch[0]) as ExecutionPlan;
  }

  /**
   * Parse plan from Anthropic-style response (legacy, kept for reference)
   */
  private parsePlanResponse(data: { content: Array<{ type: string; text: string }> }): ExecutionPlan {
    const text = data.content[0]?.text ?? '';
    return this.parsePlanResponseFromText(text);
  }

  private getPlanningSystemPrompt(): string {
    return `You are a technical project planner. Given an idea, create a detailed execution plan.

Output JSON in this exact format:
{
  "summary": "One sentence summary of the plan",
  "approach": "2-3 sentences describing the overall approach",
  "steps": [
    {
      "order": 1,
      "title": "Short action title",
      "description": "What to do in this step",
      "type": "research|design|implement|test|deploy|document",
      "agent_type": "claude|local|human",
      "estimatedMinutes": 30
    }
  ],
  "estimatedEffort": "xs|s|m|l|xl",
  "risks": ["Risk 1", "Risk 2"],
  "dependencies": ["Dependency 1"]
}

agent_type values:
- "claude": Complex analysis, coding, writing, research that requires AI
- "local": Quick tasks that could run on a local model (future capability)
- "human": Requires human judgment, approval, or physical action

Effort scale:
- xs: < 1 hour
- s: 1-4 hours
- m: 4-16 hours (1-2 days)
- l: 2-5 days
- xl: > 1 week

Guidelines:
- Break complex ideas into 3-10 steps
- Keep steps atomic and independently executable where possible
- Order steps logically (dependencies should come first)
- Be specific about what each step should produce/accomplish
- Steps marked "human" should be decision points or actions requiring user input`;
  }

  private buildPlanningPrompt(idea: IdeaData): string {
    let prompt = `Create an execution plan for this idea:\n\n`;
    prompt += `Title: ${idea.title}\n`;
    if (idea.description) {
      prompt += `Description: ${idea.description}\n`;
    }
    if (idea.category && idea.category !== 'random') {
      prompt += `Category: ${idea.category}\n`;
    }
    if (idea.domain) {
      prompt += `Domain: ${idea.domain}\n`;
    }
    return prompt;
  }

  /**
   * Create tasks in the database from approved plan steps
   */
  private async createTasksFromPlan(
    plan: ExecutionPlan,
    ideaId: string,
    tenantId: string,
    userId: string,
    executionId: string
  ): Promise<GeneratedTask[]> {
    const tasks: GeneratedTask[] = [];
    const key = await getEncryptionKey(this.env.KV, tenantId);
    const now = new Date().toISOString();

    for (const step of plan.steps) {
      const taskId = crypto.randomUUID();

      // Encrypt sensitive fields
      const encryptedTitle = await encryptField(step.title, key);
      const encryptedDescription = await encryptField(
        `${step.description}\n\nPart of execution for idea: ${ideaId}\nEstimated: ${step.estimatedMinutes} minutes`,
        key
      );

      // Insert into idea_tasks table
      await this.env.DB.prepare(`
        INSERT INTO idea_tasks (
          id, tenant_id, user_id, idea_id,
          title, description, agent_type, estimated_effort,
          sequence_order, status, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'ready', ?, ?)
      `).bind(
        taskId,
        tenantId,
        userId,
        ideaId,
        encryptedTitle,
        encryptedDescription,
        step.agent_type,
        this.minutesToEffort(step.estimatedMinutes),
        step.order,
        now,
        now
      ).run();

      // Also create a regular task for visibility
      await this.env.DB.prepare(`
        INSERT INTO tasks (
          id, tenant_id, user_id, title, description, status,
          source_type, source_reference, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, 'inbox', 'idea_execution', ?, ?, ?)
      `).bind(
        taskId,
        tenantId,
        userId,
        encryptedTitle,
        encryptedDescription,
        executionId,
        now,
        now
      ).run();

      tasks.push({
        taskId,
        title: step.title,
        status: 'pending',
      });
    }

    return tasks;
  }

  private minutesToEffort(minutes: number): 'xs' | 's' | 'm' | 'l' | 'xl' {
    if (minutes < 15) return 'xs';
    if (minutes < 60) return 's';
    if (minutes < 240) return 'm';
    if (minutes < 480) return 'l';
    return 'xl';
  }
}
